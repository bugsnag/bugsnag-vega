/**
 * This code was generated by the Kepler Codegen tool.
 *
 * It is provided as a starting template and can be modified.
 *
 * @generated by GenerateModuleCpp.js
 */

#include "BugsnagFileIO.h"
#include "external/sha1/sha1.hpp"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <string>

#include <fcntl.h>
#include <inttypes.h>
#include <unistd.h>

using namespace com::amazon::kepler::turbomodule;

namespace bugsnag {

template <typename T>
static T get_js_value(JSObject &js_object, std::string key, T default_value) {
  T result = js_object.find(key) != js_object.end()
                 ? std::get<T>(js_object[key])
                 : default_value;

  return result;
}

static JSObject create_error_result(JSObject container) {
  container["error"] = true;
  container["message"] = std::string(strerror(errno));
  container["code"] = errno;
  return container;
}

BugsnagFileIO::BugsnagFileIO() {}
BugsnagFileIO::~BugsnagFileIO() noexcept {};

JSObject BugsnagFileIO::readTextFile(std::string path) {
  auto result = JSObject();
  std::ifstream ifs(path);

  if (!ifs.is_open()) {
    return create_error_result(result);
  }

  std::string content((std::istreambuf_iterator<char>(ifs)),
                      (std::istreambuf_iterator<char>()));
  if (ifs.fail()) {
    return create_error_result(result);
  }

  result["content"] = content;
  return result;
}

ArrayBuffer BugsnagFileIO::readFile(std::string path) {
  auto result = ArrayBuffer();
  std::ifstream ifs(path, std::ios::binary);

  if (!ifs.is_open()) {
    return result;
  }

  uint8_t buffer[1024];
  while (true) {
    if (!ifs.read(reinterpret_cast<char *>(buffer), sizeof(buffer))) {
      break;
    }

    if (ifs.gcount() == 0) {
      break;
    }

    result.insert(static_cast<uint8_t *>(buffer), ifs.gcount());
  }

  return result;
}

JSObject BugsnagFileIO::writeTextFile(std::string path, std::string content) {
  auto result = JSObject();
  std::ofstream ofs(path);
  if (!ofs.is_open()) {
    return create_error_result(result);
  }

  ofs << content;

  if (ofs.fail()) {
    return create_error_result(result);
  }

  return result;
}

JSArray BugsnagFileIO::listDirectory(std::string dir) {
  auto entries = JSArray();
  for (auto const &dir_entry : std::filesystem::directory_iterator{dir}) {
    auto json_entry = JSObject();
    std::string filename = dir_entry.path().filename();
    json_entry["name"] = filename;
    json_entry["isFile"] = dir_entry.is_regular_file();
    json_entry["isDirectory"] = dir_entry.is_directory();

    entries.push_back(json_entry);
  }

  return entries;
}

bool BugsnagFileIO::mkdir(std::string dir) {
  std::error_code ec;
  std::filesystem::create_directories(std::filesystem::path{dir}, ec);
  return !ec;
}

bool BugsnagFileIO::deleteFile(std::string path) {
  std::error_code ec;
  std::filesystem::remove(std::filesystem::path{path}, ec);
  return !ec;
}

std::string BugsnagFileIO::sha1(ArrayBuffer data) {
  SHA1 digest;
  std::string dataStr = data.toString();
  digest.update(dataStr);
  return digest.final();
}

} // namespace bugsnag
